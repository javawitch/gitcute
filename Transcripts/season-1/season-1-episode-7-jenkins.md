Speaker 1 (00:00):
Welcome to the git cute podcast and today we are going to be talking about Jenkins. Stay tuned.

Speaker 1 (00:13):
Hi everyone. Welcome back to another episode a day late. But it's okay. We're not going to linger on that too much. I do want to say thank you to everyone that has left me a five star review or kind comments since last week. It's awesome. You guys are great. The reception has been kind of overwhelming but that is just something for my awkward self to have to deal with and not y'all, but thank you. And please keep those reviews coming because it helps me a whole whole lot. Like I said in the beginning we are going to be talking about Jenkins. And for people that don't know a Jenkins is, I went ahead and pulled what it is directly from their website, which is Jenkins, that IO. I highly suggest that anytime I'm talking about a particular framework or language or tool that you don't know of to pull up the tool's website so that way you can somewhat follow along or maybe take notes to be able to use that as a reference guide after this episode.

Speaker 1 (01:16):
And again, that is Jenkins dot. I O again, this is from Jenkins official site. Jenkins is an open source automation server, which enables developers around the world to reliably build, test and deploy their software. So my translation of that is that Jenkins is the tool that I think of when it comes to CICD and CICD is continuous integration slash continuous delivery slash continuous deployment. So what does that mean to somebody that has never automated a step in their application process? Because there are a lot of companies out there, they're still haven't done that yet and that's fine. There's nothing wrong with that. Nobody's judging you. So continuous integration is all centered around testing and all the automation of the testing. I did go over that when I was talking about how to test in my very first episode. Second episode. I've only, this is only episode six and I can't believe that I'm already forgetting things like this.

Speaker 1 (02:36):
The entire idea behind continuous integration is that to make sure that whatever feature you are pushing to, let's say your main repo, because we do have continuous integration even on our GitHub repo at my job is to make sure that whatever you are implementing isn't going to break anything else in the application. And that holds true when you're trying push something to prod as well. You don't want whatever feature you are writing to break that. And so instead of having to sit there and manually run the test locally, although you are running the test locally before you even try to merge this into your main branch, into your master branch, on your repository at work. Okay. But instead of having to do that again or having to have somebody sit there on the production environment and manually run those tests, then the pipeline does that for you.

Speaker 1 (03:27):
With continuous delivery, it's taking continuous integration one step further. So within continuous integration, you've already automated your testing process with continuous delivery. Now you're automating your release process. Whenever anybody talks about this that's not a software engineer, say on the business side, they always tell continuous integration and continuous delivery as a benefit to the customer, which truly it is because it makes it easier to develop features and to get them out into production to the customer base faster, but it also makes your life as a software engineer a lot easier for deployments as a full stack developer at my company, any pipeline issues are also my issue, so on that side it may not make my life easier when you have to say migrate or update job, but when your pipeline is set up correctly, it sure as hell beats you having to sit there and manually deploy your application when you can quite literally just press a button.

Speaker 1 (04:25):
Continuous delivery takes that even further and makes it so that there's no human interaction needed to deploy code deprived at all. Naturally you would know if something is wrong because if you have very good integration and regression tests, which is the actual basis for CIC D, then that obviously would never go to production. However, it makes me kind of nervous just a little bit thinking about that because I do work for a financial institution, but you know what? This is the way that everything is going and I don't know of a company that has true continuous integration, continuous deployment, continuous delivery. If you work at a company that has that, please email me@thegetcutepodcast.com because I want to know what it's like to not have to have a release day and not have to do a change order for anything because that sounds pretty freaking fantastic.

Speaker 1 (05:18):
Nerve wracking, but fantastic. Now that you have an overview of Jenkins, I kind of want to get into why I decided to do an episode on Jenkins and primarily there are a couple of reasons I genuinely like building pipelines for. There is just something so satisfying with sitting there and banging your head against the wall writing script to get something to work as a full stack engineer. It's pertinent to being successful in your role. My previous job definitely was on a full stack engineer position at all. It was quite literally a dev ops role. However, now that I am at a company where they take full stack engineer, quite literally, I, there is no way that I would be able to do my job efficiently and or well if I did not have the knowledge about Jenkins and the knowledge about the pipeline. Even if you're in a role that's not full stock, it's better for you to learn about your pipeline to see exactly how your application is built and processing deployed as well.

Speaker 1 (06:19):
I know that that at JP Morgan, the team that I was on had their own separate dev ops team and this can be structured differently per organization at JP Morgan DevOps met. Not only are they taking care of the pipeline that they're also taking care of the deployment as well, so it wasn't completely automated. A dev DevOps engineer still had to go into our repo and manually kick that off. But it, it was there. My last job, nothing was automated at all. It was quite frustrating because I had to manually deploy everything for this one particular job that I was assigned to. So that was kind of a nightmare. However, I digress. Being able to sit there and have your hands on your pipeline and get to see how exactly your application moves from beginning to end. It gives you experience with so many important parts that as a software engineer you may not necessarily see on a day to day basis.

Speaker 1 (07:16):
Especially with things like security. I would, I have to say that I didn't have a full grasp on security as a end-to-end process at all. I understand security as far as what I, what practices I need to do as a software engineer when I write code. However, when you are starting to think about where your application is going, what your application is actually doing, what it's housing, the information that it's housing, and then you see the pipeline where there's so many additional layers that are added into that just to make sure that everything is secure. It's really eyeopening, especially if you have your application hosted on AWS. I mean, I'm in the thick of studying for my AWS certification right now. So this is kind of heavy on my mind. The one thing that I noticed when I was currently helping migrate our pipeline that my current job was the use of identity and access management roles or I am roles.

Speaker 1 (08:13):
Essentially I am roles are roles that you can set up for access for different users or perhaps even applications that need to run something so that way you know who is accessing your ADB of a service. For example, say your ECE to instance at any given time and you can revoke that access Jesse's easily. The main component of Jenkins is the job. A job essentially uses Jenkins pre-packaged plugins or perhaps other plugins that you have found that you need to import in order to make your pipeline run more smoothly and allows that job to essentially finish one component of your pipeline. The way that I like set up my jobs, the way that I have learned to do the jobs is to say you have one job that gets in, verifies that you are connecting to the correct get hub repo and that I'm a PR has actually come through and it's authenticated and it's not a duplicate.

Speaker 1 (09:11):
The next one is going to be in charge of building your Boire for your project. The next one is going to be the deployment of that war to the server. The next one is going to be a regression test to make sure that everything is there and it's correct. All of these things you can apply the single responsibility methodology to that. I think it's a lot easier if for you to look at a pipeline and be able to look at the name of the jobs and see how the flow goes versus having to go and sit inside of a job looking at its build scripts, which don't get me wrong, you do that a lot if you're getting onto a pipeline that you've never even seen before. There is a lot of looking and reading their scripts to see what exactly it's doing and seeing what each plugin is doing.

Speaker 1 (09:56):
But I believe it's a lot easier if you, if you go into building a pipeline from scratch with the idea of having single use responsibility on each job. Now I'm going to go over the most used Jenkin plugins that I personally use, that me, myself as a software engineer uses. I completely understand that some people don't use certain plugins and some people use other plugins and there is a whole riot over Ray of things that y'all do. I'm just letting you know that in my experience this is what I have found the most useful. So I am going to pass that on to you. If any of you have any other plugins that you want to email me about, feel free to do so or tweet at me, whichever you prefer. But just know that I do work at a financial institution, so a lot of those plugins aren't necessarily security safe, so I'd more than likely won't be able to use them in my actual work.

Speaker 1 (11:00):
So just keeping that in mind. Oh, and also I can't even control the plugins that are used on our Jenkins instances. That's not, that's, that's our, that's a whole different team. So I mean, emailing me would be for not, but go ahead if that makes you feel better. First plugin is the source control management plugin. This one is fantastic because essentially it allows you to put in your repository Euro. I am saying repository because I know a lot of you used different things like get lab and some still use SVN, but I use get hub at work and get help in my personal development as well. Essentially it takes your repository URL and can trigger that specific job based off of a push to a specific branch that you specify within that plugin. Essentially, the way that you want to set this up is to have the branch that you want to trigger the entire pipeline.

Speaker 1 (11:58):
Be the main branch, your master branch. It could be called master master seems to give engineers anxiety. Think of how I feel as a black engineer having to say that all the time. But anyway, your main or your master branch and then it can kick off your pipeline. It's fantastic. The next plugin I want to talk about R is the credentials plugin. This is so essential. It is so essential. So how I use the credentials plugin is that it holds any good hub access that we need. Any AWS S access that we need or able to have this set up in your Jenkins project structure and you can just choose from the dropdown which access you're going to need for that job to run successfully through the security check. And it's all their handy dandy and encrypted and I love it. I could not do anything with Jenkins without it.

Speaker 1 (12:56):
The next one is the build. So essentially build build is literally just where you put all of your shell scripts for how you need to complete your job or complete that specific job. The easiest one that I'm going to use to say you need to build the ward to be able to deploy it to your server and the next job, and in this shell script you're running all of your Maven commands, you're running your connection to your AWS ECE to incense and setting all of that role and all of that great stuff. And then you are perhaps you need to carry over some variables that are being set in this job right now. You can also script that out in there as well. But one thing I do want to say about the build script is that it is very easy to get lost in that.

Speaker 1 (13:51):
Essentially whatever is happening in that script is going to be what's going to be out on your console output when you need to debug a job if something fails. So what I highly suggest is that you come in out like line breakers and dividers within your job. So when you're debugging, you're looking at this huge long ass console output log that you actually know what part of your job completed and what part failed. That has been so essential, so essential because you can easily be looking at thousands upon thousands of lines of log Justin one job and that's not even your pipeline, just one particular job. So please use line breaker comments to at least do step one, step two, whatever you want to say. Electric boom. We don't know. I'm not judging you. Just, just do it. I promise you it'll make your life easier.

Speaker 1 (14:44):
I did also want to clarify, I know that I kept saying build throughout this entire thing. This specific plugin is underneath the section. Once you're configuring a Jenkins job, I got super excited. It's called execute shell is the name of the actual plugin where you will write your bash script. So just throwing that out there. It's called execute shell under the build section in the Jenkins shop configuration. I just talked about needing to possibly save variable information within a file of some sort in order to carry that information over to the next job and you would write that out. Bash scripting that within your execute shell plugin. However, sometimes there is some information that you need at the beginning of the job in order for the job to run completely. Examples of this I would say would be I know for us we have a lot of SSL certifications that we need in order for our jobs to run for security.

Speaker 1 (15:42):
So that's something that I need to hard code into that and you are not going to be hard coding that into your execute shell because that's just ridiculous and unsafe so where you would put that information we would be underneath the metadata section of your Jenkins configuration and then you would need to select string parameter and it sounds just as it is you have the name of the parameter that you have and then you have the value as well that you would be giving that. There are a lot of other things that you can use within the metadata section but primarily all I have had to ever use this a string parameter for that. I can not tell you anything about the other plugins that are available for use underneath it. That section in the Jenkin jobs configuration, but you need to know string parameter because it is essential.

Speaker 1 (16:31):
Last but certainly not least, I will be talking about plugins that I primarily use within the post bold actions section of your Jenkins job configuration. Post build actions are essentially that exactly what happens after all of the grip that you just wrote with an execute shell is done. What do you want to happen? So there are a couple of things that can happen. You can configure and post bold actions for another job to trigger. That's the most common one because like I said, we're going to have our jobs using single responsibilities. So once one thing is done, you're going to want to trigger the next job as long as that job is stable. Okay. Stable is key here. As long as the job is stable, you want to trigger your next job to kick off the rest of the pipeline. Obviously if you can do stable, then there's actions you can take when it's unstable.

Speaker 1 (17:19):
One of those things that we use is we use the mailer plugin, which essentially allows you to configure an email address or list of email addresses in case your team doesn't have one specific email address that they use for application alerts. Here you can also tell them what exactly within the email message that you want to say. Usually it's like, Hey, this build failed somebody. Please look at this very standard professional messaging and all of that. Earlier I did talk about having to create a file within your execute shell plugin to carry over variables that you're going to need in the next job. What I didn't tell you is how you're going to do that. How you can do that is actually setting that within a Postville step. Within post build actions, there is a dropdown option for a properties file. Within that properties file there is a section where you can actually link to the properties file and considering that you have created this file within your execute shell, it should be at the root of your file structure so you can whatever you named your file.

Speaker 1 (18:23):
Hopefully it's something that properties, I probably should've mentioned that earlier, but I'm mentioning it that I'm mentioning it now. Usually build up properties is a good idea to name it. You can actually set that file name in that file property. Then it will actually carry over the information that you grabbed and stored in that file in your execute shell and carried it over to the next job. Jenkins is freaking amazing and with that note, the episode is over. I hope y'all enjoyed this very short, concise bit of information on Jenkins and how amazing it is. Like I said in the beginning of the episode, please go to Jenkins. That IO, they have a ton of documentation obviously for Jenkins and they also have a lot of really cool tutorials that would it be good for you guys to sit down and actually go through the process of it because listen to me talking about it, it's one thing.

Speaker 1 (19:16):
Maybe you learn a thing or two and maybe you'll even get even more excited about it by sitting down and going through those tutorials is absolutely essential. If you like this episode or any episode or if you just like me, if you listen on Apple podcasts, please feel free to give me a five star review. It means a lot to me. As I've said before, it helps the algorithm so more people will be able to listen to this podcast and listen to me rant about great nerdy things such as Jenkins. As always, if you have any questions, comments or concerns, feel free to email me at the git cute podcast at gmail dot com. You can also follow the podcast at get cute podcast on Twitter and Instagram. As far as announcements, I have accepted a panel position at the millennial summit that is going to be held within Wilmington, Delaware represent a, it's going to be August 5th and sixth. I believe my panel is on August

Speaker 2 (20:08):
Six.

Speaker 1 (20:12):
Either way the link to it will be down in the show description. I can't remember which day, but just know that I'm going to be there both days. More than likely, if you want to come in, hear me talk about diversity and inclusion on this panel, feel free. Diversity inclusion's a passion of mine. If none of you know that or have picked up on that by now, it is and it would be great to see some familiar faces. Again, I will link the information to that in the show notes, so that way you can go and buy your tickets and come hear me talk with a bunch of other amazing people and just be fabulous and amazing. So again, thank you all so much. I will see y'all on the next episode and

Speaker 3 (20:53):
Bye.

